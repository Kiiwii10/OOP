Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'isKindOf' stamp: 'AB 2/27/2024 18:44'!isKindOf: classOrInterface	((self class) == Object) "Recursion end"	ifTrue: [ ^(self isKindOf: classOrInterface). ].		"check up the inheritance tree or implementation of an interface"	 ^(((super isKindOf: classOrInterface) or: (((self class) behavesLike) includes: classOrInterface)))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'isInterface' stamp: 'AB 2/27/2024 18:45'!isInterface	^(isInterface)! !!MyObject class methodsFor: 'behavesLike' stamp: 'AB 2/27/2024 18:42'!behavesLike	|behavesSet|	(self == MyObject) 		"Recursion end"	ifTrue:[ ^(Set new). ].		behavesSet := Set new.		(isInterface) 	ifTrue: [ behavesSet add: self. ].  "An interface behaves like itself"		behavesSet  addAll: (self instVarNamed: 'behavesLike'). "Add all of the interfaces in my behavesLike Set"	behavesSet addAll: self superclass behavesLike. "Recursion on parent"	behavesLike do: [: interface | behavesSet addAll: (interface behavesLike)]. "Recursion on all interfaces"		^behavesSet.! !!MyObject class methodsFor: 'isImplemented' stamp: 'AB 3/2/2024 13:24'!isImplemented	|interface_methods|	(self isInterface)	ifFalse:[ AssertionFailure signal:  ((self asString), ' is not an interface!!') ].		interface_methods := Set new.	(self behavesLike) collect: [: interface | interface_methods addAll: (interface selectors)] . "For each interface I behave like - add all methods"		(interface_methods size == 0) "Empy interface"	ifTrue:[		(MyObject allSubclasses) collect: [: sub_class | "For each of MyObject subclasses"			((sub_class isInterface == false) and: ((sub_class behavesLike) includes: self)) "If the class is NOT an interface and it behaves like me"				ifTrue:[ ^true. ] "Interface is implemented in an 'empty' way"		].		^false.	].	"else... (the interface isn't empty) "	(MyObject allSubclasses) do: [: sub_class |  	"For each of MyObject subclasses"		(sub_class isInterface) 		ifFalse:[ 	"If the class is NOT an interface"			( (sub_class behavesLike) includes: self ) 	"if the class behaves like me"			ifTrue:[				(self areMethods: interface_methods ImplementedInClass: sub_class) "If the class implements me"				ifTrue: [^true.].			]			]	 ].	^false. "couldn't find a class that implements me :("	! !!MyObject class methodsFor: 'ambiguities' stamp: 'AB 3/2/2024 17:49'!ambiguities    | all_methods ambiguities_methods sorted_ambiguities |	(self == MyObject)  "Recursion end"	ifTrue: [ ^ (SortedCollection new) ].    	all_methods := Set new.      sorted_ambiguities := SortedCollection new.      ambiguities_methods := Set new.          (self behavesLike) do: [:interface |    				"For each interface I behave like (including myself)"            	(interface selectors) do: [:selector |				"For each method defined in said interface"           		(all_methods includes: selector)				                 	ifTrue: [ambiguities_methods add: selector]	"If method already encountered - count it as ambiguous"                 	ifFalse: [all_methods add: selector].			"If not encountered yet - remember it for later checks"           	].      ].	sorted_ambiguities := ((ambiguities_methods asSortedCollection) sort). "need to return sorted colection"    	 ^sorted_ambiguities! !!MyObject class methodsFor: 'auxiliary' stamp: 'AB 3/2/2024 13:23'!areMethods: allMethods ImplementedInClass: aClass 	allMethods do: [:func |				(aClass canUnderstand: func)  	"if the class can understand the message - the function is implemented"		ifFalse: [ ^false. ].	].	^true.! !!MyObject class methodsFor: 'auxiliary' stamp: 'AB 3/2/2024 16:31'!getArguments: aSourceCode	| lines firstLine arguments index result |	"Extract method arguments from the source code."    	lines := aSourceCode findTokens: String cr, String lf. "split aSourceCode to seprerate lines by \r and \n"    	firstLine := lines first.		arguments := firstLine findTokens: ':'. "split the first line (that contains all the args) by :"	arguments := arguments joinSeparatedBy: ' '. "join with spaces"	arguments := arguments findTokens: ' '. "split by space - each 'cell' in arguments will contain a single word"		index := 1.	result := OrderedCollection new.	arguments do: [ :word | "For each word in arguments"		(index \\\ 2 = 0) 		ifTrue: [result add: word]. "all the args are in even cells"		index := index + 1.	].	^result.	! !!MyObject class methodsFor: 'auxiliary' stamp: 'AB 3/2/2024 16:46'!getTypeCheckInjectLineNumber: aSourceCode     	| lines trimmedLine |	"Determine the starting line number for injecting type check assertions."    	lines := aSourceCode findTokens: String cr, String lf. "split aSourceCode to lines by \r and \n" 	(lines size < 2) 	ifTrue: [^1.] "really boring short function - type-check before return"	ifFalse:[		trimmedLine := (lines at: 2) copy.        	trimmedLine := trimmedLine select: [:char | char isSeparator not]. "remove white spaces"		(trimmedLine beginsWith: '|') "check if we have local vars"		ifTrue: [^2]. "type-check after local var decleration"		^1. 		]! !!MyObject class methodsFor: 'new' stamp: 'AB 3/2/2024 12:55'!new	(self isInterface)	ifTrue:[		AssertionFailure signal: 'Interfaces can not be instantiated!!'.	].	^(super new)! !!MyObject class methodsFor: 'subclass' stamp: 'AB 2/27/2024 20:07'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	^(self subclass: aSubclassName		isInterface: false		behavesLike: {}		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName).! !!MyObject class methodsFor: 'subclass' stamp: 'AB 3/2/2024 15:18'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	|subclass_inst|	(isInterface and: [ self ~= MyObject ])	ifTrue:[ AssertionFailure signal: 'Interfaces must derive from MyObject!!' ].	(isInterface and: [ (instVarNames size)~=0 ])	ifTrue:[ AssertionFailure signal: 'Interfaces can not have state!!'].	( (isInterface == false) and: [(self isInterface == true)] )	ifTrue:[ AssertionFailure signal: 'Classes can not derive from an interface!!' ].		aCollection do: [ :c |		(c isInterface == false) 		ifTrue: [ AssertionFailure signal: 'Can not behave like a non-interface!!'. ].	].	subclass_inst := super subclass: aSubclassName						     instanceVariableNames: instVarNames						     classVariableNames: classVarNames						     poolDictionaries: poolDictionaries						     category: aCategoryName.	subclass_inst instVarNamed: 'isInterface' put: isInterface.	subclass_inst instVarNamed: 'behavesLike' put: (aCollection).	^subclass_inst.	! !!MyObject class methodsFor: 'compile' stamp: 'AB 3/2/2024 14:30'!compile: aSourceCode	| firstLine |	"Compile the source code, ensuring interfaces do not define behavior."    	firstLine := (aSourceCode findTokens: String cr, String lf) at: 1.        	( self isInterface ) 	ifTrue: [		( aSourceCode lines size > 1 )		ifTrue: [  	          AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'.            ].        ].        ^super compile: aSourceCode.! !!MyObject class methodsFor: 'compile' stamp: 'AB 3/2/2024 16:10'!compile: aSourceCode where: anOrderedCollection	| lines args lineToInjectIndex |	"Compile the source code with type checks based on anOrderedCollection."    	args := self getArguments: aSourceCode.    	lines := aSourceCode findTokens: String cr, String lf.        	( args size = anOrderedCollection size )	ifFalse: [		AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	].        lineToInjectIndex := self getTypeCheckInjectLineNumber: aSourceCode.    args withIndexDo: [:arg :idx | 	"For each non-nil argument"        (anOrderedCollection at: idx) ifNotNil: [ "add type check line in the correct place."            | typeCheckLine |            typeCheckLine := '( ', arg, ' isKindOf: ', ((anOrderedCollection at: idx ) asString),                 ' ) ifFalse: [ AssertionFailure signal: ''Type mismatch!! Argument ',  "throw the error!!"                idx printString, ' should be ', ((anOrderedCollection at: idx) asString), '''.].'.            lines add: typeCheckLine afterIndex: lineToInjectIndex.            lineToInjectIndex := lineToInjectIndex + 1. "keep going in case we have more arguments"        ].    ].         ^self compile: (lines joinSeparatedBy: String cr). "now we can call compile regularly"! !