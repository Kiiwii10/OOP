Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'exp' stamp: 'DM 1/26/2024 18:29'!exp	^exp.! !!Monom methodsFor: 'exp' stamp: 'DM 1/26/2024 18:30'!exp: anInteger	((anInteger isKindOf: Integer) and: [anInteger >= 0])		ifTrue: [exp := anInteger]		ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'coef' stamp: 'DM 1/26/2024 18:33'!coef	^coef.! !!Monom methodsFor: 'coef' stamp: 'DM 1/26/2024 18:38'!coef: anInteger	(anInteger isKindOf: Integer)		ifTrue: [coef:=anInteger]		ifFalse: [self error: 'invalid input']! !!Monom methodsFor: 'initialize-release' stamp: 'AB 1/30/2024 17:37'!initialize	exp := 0.	coef:=0.! !!Monom methodsFor: 'derivative' stamp: 'DM 1/26/2024 20:16'!derivative	|derMon|	derMon := Monom new.	(self exp = 0) "same as (self exp = 0 or: self coef = 0) mathematically"		ifFalse: [				derMon exp: self exp - 1.				derMon coef: (self coef) * (self exp).				].	^ derMon.! !!Monom methodsFor: 'copy' stamp: 'DM 1/26/2024 20:24'!copy	|aMonom|	aMonom := Monom new.	aMonom coef:  self coef.	aMonom exp: self exp.	^ aMonom.	! !!Monom methodsFor: 'eval' stamp: 'AB 1/30/2024 17:36'!eval: anInteger	(anInteger isKindOf: Integer)		ifTrue: [^ ((anInteger raisedTo: self exp) * self coef)]		ifFalse: [self error: 'invalid input'.]! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'block' stamp: 'AB 1/28/2024 21:02'!block	^block.! !!PolyStream methodsFor: 'addCoef' stamp: 'AB 2/1/2024 17:44'!addCoef: coef withExp: exp	"Add a monom to the polynom"	"Since the polynom will be evaluated in reverse order(we already know if there is a filter applied)"	"If the added values are included in a future filter - ignore them"	((exp isKindOf:Integer) and: (coef isKindOf: Integer)) 	ifTrue: [ 		(exp >= 0) 								"check validity"		ifTrue: [			|prevBlock|			prevBlock := self block.			block := [:xVal :filteredExp |				(filteredExp includesKey: exp)				ifTrue: [prevBlock value:xVal value:filteredExp.] 										"calc without added monom"				ifFalse:[(coef * (xVal raisedToInteger: exp)) + (prevBlock value:xVal value:filteredExp).]	"calc old and add the new monom"				].					]	 		ifFalse: [self error: 'invalid input']		]	ifFalse: [self error: 'invalid input']  ! !!PolyStream methodsFor: 'add' stamp: 'AB 1/30/2024 15:51'!add: aPolyStream	"add another polymon by evaluating both block"		(aPolyStream isKindOf: PolyStream)	ifTrue: [ | prevBlock |		prevBlock := self block.		block := [:xVal :filteredExp |			((prevBlock value:xVal value:filteredExp) + (aPolyStream block value:xVal value:filteredExp)).			].		]	ifFalse: [self error: 'invalid input'.].! !!PolyStream methodsFor: 'multiplyBy' stamp: 'AB 1/30/2024 16:21'!multiplyBy: anInteger	"evaluate the block and multiply"		(anInteger isKindOf: Integer)	ifTrue: [ |prevBlock|			prevBlock := self block.			block := [ :xVal :fliteredExp |					    anInteger * (prevBlock value: xVal value: fliteredExp).					].			]	ifFalse: [ self error: 'invalid input' ]! !!PolyStream methodsFor: 'filter' stamp: 'AB 1/30/2024 16:20'!filter: aSet	"Since we stack blocks, on fallback all prev monoms with exp in aSet will be ignored, but monoms added after will be calculated"	|aSetCopy prevBlock|	aSetCopy := aSet deepCopy.										"make copy of given set - so future changes to it won't apply"	prevBlock := self block.	block := [:xVal :fliteredExp | 			   aSetCopy do: [:exp | fliteredExp add: exp->0].			"add the exp to the filteredExp dict - so they can be ignored when calculating"			   prevBlock value:xVal value:fliteredExp.								].	! !!PolyStream methodsFor: 'eval' stamp: 'AB 1/30/2024 16:13'!eval: anInteger	"evaluate the stack of blocks accumulated"		(anInteger isKindOf: Integer)		ifTrue:[ ^(block value:anInteger value: Dictionary new).]		ifFalse:[ self error: 'invalid input'.]! !!PolyStream methodsFor: 'substitute' stamp: 'AB 1/30/2024 15:56'!substitute: anInteger	"evaluate the block with the sub integer insted of the original one"		((anInteger isKindOf: Integer) and: [(anInteger~=0)])		ifTrue: [			|prevBlock|				prevBlock := self block.				block:=[:xVal :filteredExp | 						prevBlock value: (anInteger * xVal) value:filteredExp. ]				]		ifFalse: [self error: 'invalid input'].! !!PolyStream methodsFor: 'initialize-release' stamp: 'AB 1/30/2024 15:38'!initialize	"The polynom will be built from 0 gradually by adding monoms and polymons"	"The blocks will 'stack' and on call to eval will be executed in reverse order"		block := [:xVal :filteredExp | 		"xVal will be used to evaluate the polynom"		filteredExp := Dictionary new. 	"no filtered exp to ignore"		0.] 								"return from init block is 0"																	! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'addMonom' stamp: 'AB 1/30/2024 17:45'!addMonom: aMonom	|exists|	exists := False.	(aMonom isKindOf: Monom)		ifTrue: [(aMonom coef = 0) "don't care if 0"				ifFalse:					[monoms do:						[:m | (m exp  = aMonom exp)							ifTrue: [m coef: m coef + aMonom coef.		"update coef with value given"									exists := True.].							(m coef = 0) ifTrue: [monoms remove: m]. "can't hold a monom with coef=0"						].					(exists = False)						ifTrue: [monoms add: aMonom copy] 			"add a copy of the new monom"					]				]		ifFalse: [self error: 'invalid input'.] ! !!Polynom methodsFor: 'asDictionary' stamp: 'DM 1/26/2024 21:31'!asDictionary	|polyDict|	polyDict := Dictionary new.	monoms do: "assuming no 0 values"		[:m | polyDict add: m exp -> m coef].	^ polyDict.	! !!Polynom methodsFor: 'derivative' stamp: 'AB 1/28/2024 20:03'!derivative	|derpPoly derpMonom|	derpPoly := Polynom new.	monoms do:		[:m | derpMonom := m derivative.			  (derpMonom coef = 0)			  ifFalse:[derpPoly addMonom: derpMonom].		].	^derpPoly.	! !!Polynom methodsFor: 'eval' stamp: 'AB 1/30/2024 17:42'!eval: anInteger	|val|	(anInteger isKindOf: Integer)	ifTrue:[			val := 0.			monoms do: 				[:m | val := val + (m eval: anInteger)]		   ]	ifFalse:[self error: 'invalid input'].	^val.! !!Polynom methodsFor: 'add' stamp: 'AB 1/30/2024 17:38'!add: aPolynom	|polySum|	(aPolynom isKindOf: Polynom)	ifTrue: [		polySum := Polynom new.		(self monoms) do: [:m | polySum addMonom: m]. 			"add copies of all monoms from self - addMonom creates a copy of the monom passed to it"		(aPolynom monoms) do: [:m | polySum addMonom: m].	"add copies of all monoms from aPolymon"		^ polySum.		] 	ifFalse: [self error: 'invalid input'.]! !!Polynom methodsFor: 'monoms' stamp: 'DM 1/26/2024 21:36'!monoms	^monoms! !!Polynom methodsFor: 'multiplyByMonom' stamp: 'AB 1/30/2024 17:43'!multiplyByMonom: aMonom	(aMonom isKindOf: Monom)	ifTrue:[ 		(aMonom coef = 0)			ifTrue: [monoms removeAll.	]			ifFalse: [monoms do: 						[:m | m exp: m exp + aMonom exp.							  m coef: m coef * aMonom coef.						]				     ]			]	ifFalse: [self error: 'invalid input'.].! !!Polynom methodsFor: 'initialize-release' stamp: 'AB 1/30/2024 17:43'!initialize	monoms := OrderedCollection new.! !